const { Order, User, Branch } = require('../../models');
const DeliveryService = require('../../services/deliveryService');
const SocketManager = require('../../config/socketConfig');

function getStatusMessage(status) {
  const messages = {
    pending: 'Buyurtmangiz kutilmoqda',
    confirmed: 'Buyurtmangiz tasdiqlandi',
    preparing: 'Buyurtmangiz tayyorlanmoqda',
    ready: 'Buyurtmangiz tayyor!',
    on_delivery: 'Buyurtmangiz yetkazilmoqda',
    delivered: 'Buyurtmangiz yetkazildi',
    picked_up: 'Buyurtmangiz olib ketildi',
    completed: 'Buyurtmangiz yakunlandi',
    cancelled: 'Buyurtmangiz bekor qilindi'
  };
  return messages[status] || 'Status yangilandi';
}

function getStatusEmoji(status) {
  const emojis = {
    pending: '⏳',
    confirmed: '✅',
    preparing: '👨‍🍳',
    ready: '🍽️',
    on_delivery: '🚚',
    delivered: '✅',
    picked_up: '📦',
    completed: '🎉',
    cancelled: '❌'
  };
  return emojis[status] || '📋';
}

function getEstimatedTime(status, orderType) {
  if (status === 'confirmed') return orderType === 'delivery' ? '30-45 daqiqa' : '15-25 daqiqa';
  if (status === 'preparing') return orderType === 'delivery' ? '20-30 daqiqa' : '10-15 daqiqa';
  if (status === 'ready' && orderType !== 'delivery') return 'Olib ketishingiz mumkin';
  return null;
}

// GET /api/orders
async function listOrders(req, res) {
  try {
    const Helpers = require('../../utils/helpers');
    const { page, limit, skip } = Helpers.getPaginationParams(req.query);
    const { status, orderType, dateFrom, dateTo, search, courier, branch: branchFilter } = req.query;

    let query = {};
    const branchId = req.user.role === 'superadmin' ? null : req.user.branch;
    if (branchId) query.branch = branchId;
    if (req.user.role === 'superadmin' && branchFilter) query.branch = branchFilter;
    if (status) query.status = status;
    if (orderType) query.orderType = orderType;
    if (dateFrom || dateTo) {
      query.createdAt = {};
      if (dateFrom) query.createdAt.$gte = new Date(dateFrom);
      if (dateTo) query.createdAt.$lte = new Date(dateTo);
    }
    if (search && String(search).trim().length > 0) {
      const text = String(search).trim();
      const regex = new RegExp(text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');
      query.$or = [
        { orderId: { $regex: regex } },
        { orderNumber: { $regex: regex } },
        { 'customerInfo.name': { $regex: regex } },
        { 'customerInfo.phone': { $regex: regex } },
      ];
    }

    let orders = await Order.find(query)
      .populate('user', 'firstName lastName phone')
      .populate('deliveryInfo.courier', 'firstName lastName phone courierInfo')
      .populate('items.product', 'name price')
      .populate('branch', 'name title address')
      .limit(limit)
      .skip(skip)
      .sort({ createdAt: -1 });

    if (courier === 'assigned') query['deliveryInfo.courier'] = { $ne: null };
    else if (courier === 'unassigned') query['deliveryInfo.courier'] = { $in: [null, undefined] };

    const total = await Order.countDocuments(query);

    try {
      let origin = null;
      if (req.user.role !== 'superadmin' && req.user.branch) {
        const branch = await Branch.findById(req.user.branch);
        if (branch?.address?.coordinates?.latitude && branch?.address?.coordinates?.longitude) {
          origin = { lat: branch.address.coordinates.latitude, lon: branch.address.coordinates.longitude };
        }
      }
      if (!origin && process.env.DEFAULT_RESTAURANT_LAT && process.env.DEFAULT_RESTAURANT_LON) {
        origin = { lat: parseFloat(process.env.DEFAULT_RESTAURANT_LAT), lon: parseFloat(process.env.DEFAULT_RESTAURANT_LON) };
      }
      const enriched = [];
      for (const o of orders) {
        const obj = o.toObject();
        if (obj.orderType === 'delivery' && obj.deliveryInfo?.location?.latitude && obj.deliveryInfo?.location?.longitude) {
          const calc = await DeliveryService.calculateDeliveryTime({ latitude: obj.deliveryInfo.location.latitude, longitude: obj.deliveryInfo.location.longitude }, obj.items, origin);
          const fee = await DeliveryService.calculateDeliveryFee({ latitude: obj.deliveryInfo.location.latitude, longitude: obj.deliveryInfo.location.longitude }, obj.total ?? obj.totalAmount ?? 0);
          obj.deliveryMeta = {
            distanceKm: calc?.distance ?? null,
            etaMinutes: calc?.totalTime ?? null,
            preparationMinutes: calc?.preparationTime ?? null,
            deliveryMinutes: calc?.deliveryTime ?? null,
            deliveryFee: fee?.fee ?? null,
            isFreeDelivery: fee?.isFreeDelivery ?? false
          };
        }
        enriched.push(obj);
      }
      orders = enriched;
    } catch (enrichErr) {
      console.error('Order enrichment error:', enrichErr);
    }

    res.json({ success: true, data: { orders, pagination: Helpers.buildPagination(total, page, limit) } });
  } catch (error) {
    console.error('Get orders error:', error);
    res.status(500).json({ success: false, message: 'Buyurtmalarni olishda xatolik!' });
  }
}

// GET /api/orders/:id
async function getOrder(req, res) {
  try {
    const { id } = req.params;
    const branchId = req.user.role === 'superadmin' ? null : req.user.branch;
    const query = { _id: id };
    if (branchId) query.branch = branchId;
    const orderDoc = await Order.findOne(query)
      .populate('user', 'firstName lastName phone address')
      .populate('deliveryInfo.courier', 'firstName lastName phone courierInfo')
      .populate('items.product', 'name price description')
      .populate('branch', 'name title address');
    if (!orderDoc) return res.status(404).json({ success: false, message: 'Buyurtma topilmadi!' });
    let order = orderDoc.toObject();
    try {
      if (order.orderType === 'delivery' && order.deliveryInfo?.location?.latitude && order.deliveryInfo?.location?.longitude) {
        let origin = null;
        if (branchId) {
          const branch = await Branch.findById(branchId);
          if (branch?.address?.coordinates?.latitude && branch?.address?.coordinates?.longitude) {
            origin = { lat: branch.address.coordinates.latitude, lon: branch.address.coordinates.longitude };
          }
        }
        if (!origin && process.env.DEFAULT_RESTAURANT_LAT && process.env.DEFAULT_RESTAURANT_LON) {
          origin = { lat: parseFloat(process.env.DEFAULT_RESTAURANT_LAT), lon: parseFloat(process.env.DEFAULT_RESTAURANT_LON) };
        }
        const calc = await DeliveryService.calculateDeliveryTime({ latitude: order.deliveryInfo.location.latitude, longitude: order.deliveryInfo.location.longitude }, order.items, origin);
        const fee = await DeliveryService.calculateDeliveryFee({ latitude: order.deliveryInfo.location.latitude, longitude: order.deliveryInfo.location.longitude }, order.total ?? order.totalAmount ?? 0);
        order.deliveryMeta = {
          distanceKm: calc?.distance ?? null,
          etaMinutes: calc?.totalTime ?? null,
          preparationMinutes: calc?.preparationTime ?? null,
          deliveryMinutes: calc?.deliveryTime ?? null,
          deliveryFee: fee?.fee ?? null,
          isFreeDelivery: fee?.isFreeDelivery ?? false
        };
      }
    } catch (e) {}
    res.json({ success: true, data: { order } });
  } catch (error) {
    console.error('Get single order error:', error);
    res.status(500).json({ success: false, message: 'Buyurtma ma\'lumotlarini olishda xatolik!' });
  }
}

// GET /api/orders/stats
async function getStats(req, res) {
  try {
    const match = {};
    const branchId = req.user.role === 'superadmin' ? null : req.user.branch;
    if (branchId) match.branch = branchId;
    if (req.user.role === 'superadmin' && req.query.branch) match.branch = req.query.branch;
    const result = await Order.aggregate([
      { $match: match },
      { $group: {
        _id: null,
        pending: { $sum: { $cond: [{ $eq: ['$status', 'pending'] }, 1, 0] } },
        confirmed: { $sum: { $cond: [{ $eq: ['$status', 'confirmed'] }, 1, 0] } },
        preparing: { $sum: { $cond: [{ $eq: ['$status', 'preparing'] }, 1, 0] } },
        ready: { $sum: { $cond: [{ $eq: ['$status', 'ready'] }, 1, 0] } },
        delivered: { $sum: { $cond: [{ $in: ['$status', ['delivered', 'completed', 'picked_up', 'on_delivery']] }, 1, 0] } },
        cancelled: { $sum: { $cond: [{ $eq: ['$status', 'cancelled'] }, 1, 0] } },
      } }
    ]);
    const stats = result[0] || { pending: 0, confirmed: 0, preparing: 0, ready: 0, delivered: 0, cancelled: 0 };
    res.json({ success: true, data: { stats } });
  } catch (error) {
    console.error('Orders stats error:', error);
    res.status(500).json({ success: false, message: 'Buyurtma statistikasini olishda xatolik!' });
  }
}

// PATCH /api/orders/:id/status
async function updateStatus(req, res) {
  try {
    const { id } = req.params;
    const { status, message: customMessage } = req.body;
    const branchId = req.user.role === 'superadmin' ? null : req.user.branch;
    const validStatuses = ['pending', 'confirmed', 'ready', 'assigned', 'on_delivery', 'delivered', 'picked_up', 'completed', 'cancelled'];
    if (!validStatuses.includes(status)) return res.status(400).json({ success: false, message: 'Noto\'g\'ri status!' });
    const existing = await Order.findById(id).populate('user', 'firstName lastName phone telegramId');
    if (!existing) return res.status(404).json({ success: false, message: 'Buyurtma topilmadi!' });
    if (branchId) {
      if (existing.branch && String(existing.branch) !== String(branchId)) return res.status(403).json({ success: false, message: 'Bu buyurtmani o\'zgartirish huquqi yo\'q' });
    }
    if (!existing.branch && branchId) existing.branch = branchId;
    existing.status = status;
    existing.updatedAt = new Date();
    existing.statusHistory = existing.statusHistory || [];
    
    // 🔧 FIX: Status history ga qo'shish
    const statusMessage = customMessage || getStatusMessage(status);
    existing.statusHistory.push({ 
      status, 
      message: statusMessage, 
      timestamp: new Date(), 
      updatedBy: req.user._id 
    });
    
    const order = await existing.save();
    // Socket events
    try {
      SocketManager.emitStatusUpdate(order.user._id, { orderId: order._id, orderNumber: order.orderId, status, message: statusMessage, updatedAt: new Date(), estimatedTime: getEstimatedTime(status, order.orderType) });
    } catch (e) {}
    res.json({ success: true, message: 'Buyurtma holati yangilandi!', data: { order } });
    try {
      if (status === 'picked_up' && order.orderType === 'pickup') {
        const idForTimer = String(order._id);
        console.log('🔄 Setting up pickup completion timer for order:', idForTimer);
        setTimeout(async () => {
          try {
            const fresh = await Order.findById(idForTimer);
            if (fresh && fresh.status === 'picked_up') {
              console.log('✅ Auto-completing pickup order:', idForTimer);
              fresh.status = 'completed';
              fresh.updatedAt = new Date();
              fresh.statusHistory.push({
                status: 'completed',
                message: 'Buyurtma avtomatik yakunlandi (pickup)',
                timestamp: new Date(),
                updatedBy: 'system'
              });
              await fresh.save();
              
              // Socket notification
              SocketManager.emitOrderUpdate(idForTimer, { 
                status: 'completed', 
                branchId: String(fresh.branch || ''),
                message: 'Buyurtma yakunlandi',
                updatedAt: new Date()
              });
              
              // User notification
              SocketManager.emitStatusUpdate(fresh.user._id, {
                orderId: fresh._id,
                orderNumber: fresh.orderId,
                status: 'completed',
                message: 'Buyurtmangiz yakunlandi!',
                updatedAt: new Date()
              });
            }
          } catch (error) {
            console.error('❌ Pickup completion timer error:', error);
          }
        }, 10000); // 10 seconds
      }
    } catch (error) {
      console.error('❌ Pickup timer setup error:', error);
    }
  } catch (error) {
    console.error('Update order status error:', error);
    res.status(500).json({ success: false, message: 'Buyurtma holatini yangilashda xatolik!' });
  }
}

// GET /api/admin/orders/:id
async function getOrderById(req, res) {
  try {
    const { id } = req.params;
    const branchId = req.user.role === 'superadmin' ? null : req.user.branch;
    const query = { _id: id };
    if (branchId) query.branch = branchId;
    const orderDoc = await Order.findOne(query)
      .populate('user', 'firstName lastName phone address')
      .populate('deliveryInfo.courier', 'firstName lastName phone courierInfo')
      .populate('items.product', 'name price description')
      .populate('branch', 'name title address');
    if (!orderDoc) return res.status(404).json({ success: false, message: 'Buyurtma topilmadi!' });
    let order = orderDoc.toObject();
    try {
      if (order.orderType === 'delivery' && order.deliveryInfo?.location?.latitude && order.deliveryInfo?.location?.longitude) {
        let origin = null;
        if (branchId) {
          const Branch = require('../../models/Branch');
          const branch = await Branch.findById(branchId);
          if (branch?.address?.coordinates?.latitude && branch?.address?.coordinates?.longitude) {
            origin = { lat: branch.address.coordinates.latitude, lon: branch.address.coordinates.longitude };
          }
        }
        if (!origin && process.env.DEFAULT_RESTAURANT_LAT && process.env.DEFAULT_RESTAURANT_LON) {
          origin = { lat: parseFloat(process.env.DEFAULT_RESTAURANT_LAT), lon: parseFloat(process.env.DEFAULT_RESTAURANT_LON) };
        }
        const DeliveryService = require('../../services/deliveryService');
        const calc = await DeliveryService.calculateDeliveryTime({ latitude: order.deliveryInfo.location.latitude, longitude: order.deliveryInfo.location.longitude }, order.items, origin);
        const fee = await DeliveryService.calculateDeliveryFee({ latitude: order.deliveryInfo.location.latitude, longitude: order.deliveryInfo.location.longitude }, order.total ?? order.totalAmount ?? 0);
        order.deliveryMeta = {
          distanceKm: calc?.distance ?? null,
          etaMinutes: calc?.totalTime ?? null,
          preparationMinutes: calc?.preparationTime ?? null,
          deliveryMinutes: calc?.deliveryTime ?? null,
          deliveryFee: fee?.fee ?? null,
          isFreeDelivery: fee?.isFreeDelivery ?? false
        };
      }
    } catch (e) {}
    res.json({ success: true, data: { order } });
  } catch (error) {
    console.error('Get single order error:', error);
    res.status(500).json({ success: false, message: 'Buyurtma ma\'lumotlarini olishda xatolik!' });
  }
}

// PATCH /api/orders/:id/assign-courier
async function assignCourier(req, res) {
  try {
    const { id } = req.params;
    const { courierId } = req.body;
    const branchId = req.user.role === 'superadmin' ? null : req.user.branch;
    const courier = await User.findOne({ _id: courierId, role: 'courier', isActive: true });
    if (!courier) return res.status(400).json({ success: false, message: 'Haydovchi topilmadi yoki mavjud emas!' });
    const query = { _id: id };
    if (branchId) query.branch = branchId;
    const existingOrder = await Order.findOne(query).select('status deliveryInfo.courier orderId');
    if (!existingOrder) return res.status(404).json({ success: false, message: 'Buyurtma topilmadi!' });
    if (existingOrder.status === 'delivered' || existingOrder.status === 'completed' || existingOrder.status === 'cancelled') {
      return res.status(400).json({ success: false, message: 'Ushbu buyurtma yakunlangan yoki bekor qilingan.' });
    }
    if (existingOrder.deliveryInfo?.courier) {
      if (String(existingOrder.deliveryInfo.courier) === String(courierId)) {
        // Same courier already assigned - return success instead of error
        console.log(`Courier ${courierId} already assigned to order ${existingOrder.orderId} - returning success`);
        return res.json({ success: true, message: 'Kuryer allaqachon tayinlangan.' });
      } else {
        // Allow re-assignment to a different courier
        console.log(`Re-assigning courier for order ${existingOrder.orderId} from ${existingOrder.deliveryInfo.courier} to ${courierId}`);
      }
    }
    const update = { 'deliveryInfo.courier': courierId, updatedAt: new Date() };
    // 🔧 FIX: Use centralized status service for assign
    // update.status = 'assigned'; // Will be handled by OrderStatusService
    
    // Update courier assignment
    const order = await Order.findOneAndUpdate(
      query, 
      update, 
      { new: true }
    )
      .populate('deliveryInfo.courier', 'firstName lastName phone courierInfo')
      .populate('user', 'firstName lastName phone telegramId')
      .populate('branch', 'address coordinates');
    
    // 🔧 FIX: Use centralized status service
    const OrderStatusService = require('../../services/orderStatusService');
    
    // Only update status to 'assigned' if the order is not already in ready/preparing state
    const targetStatus = ['ready', 'preparing'].includes(order.status) ? order.status : 'assigned';
    
    if (targetStatus === 'assigned') {
      await OrderStatusService.updateStatus(order._id, 'assigned', {
        message: `Kuryer tayinlandi: ${courier.firstName} ${courier.lastName}`,
        updatedBy: req.user._id
      });
    } else {
      // Just emit courier assignment notification without status change
      const SocketManager = require('../../config/socketConfig');
      SocketManager.emitOrderUpdate(order._id.toString(), {
        type: 'courier-assigned',
        orderId: order.orderId,
        courierName: `${courier.firstName} ${courier.lastName}`,
        courierPhone: courier.phone,
        message: `Kuryer tayinlandi: ${courier.firstName} ${courier.lastName}`,
        timestamp: new Date()
      });
    }
    if (!order) return res.status(404).json({ success: false, message: 'Buyurtma topilmadi!' });
    
    // Real-time notification handled by OrderStatusService
    
    // Courier notification handled by OrderStatusService
    
    // Notify customer that order is on delivery with ETA
    try {
      if (order.user?.telegramId && order.orderType === 'delivery') {
        let etaText = '';
        try {
          if (order?.deliveryInfo?.location?.latitude && order?.deliveryInfo?.location?.longitude) {
            let origin = null;
            const branchIdForOrigin = order?.branch?._id || order?.branch;
            if (branchIdForOrigin) {
              const b = await Branch.findById(branchIdForOrigin);
              if (b?.address?.coordinates?.latitude && b?.address?.coordinates?.longitude) {
                origin = { lat: b.address.coordinates.latitude, lon: b.address.coordinates.longitude };
              }
            }
            if (!origin && process.env.DEFAULT_RESTAURANT_LAT && process.env.DEFAULT_RESTAURANT_LON) {
              origin = { lat: parseFloat(process.env.DEFAULT_RESTAURANT_LAT), lon: parseFloat(process.env.DEFAULT_RESTAURANT_LON) };
            }
            const calc = await DeliveryService.calculateDeliveryTime({ latitude: order.deliveryInfo.location.latitude, longitude: order.deliveryInfo.location.longitude }, order.items, origin || undefined);
            if (calc?.totalTime) etaText = `${calc.totalTime} daqiqa`;
          }
        } catch {}
        if (!etaText && order.deliveryMeta?.etaMinutes) etaText = `${order.deliveryMeta?.etaMinutes} daqiqa`;
        if (!etaText) etaText = 'taxminan 30-45 daqiqa';
        const courierName = `${order.deliveryInfo?.courier?.firstName || ''} ${order.deliveryInfo?.courier?.lastName || ''}`.trim();
        const courierPhone = order.deliveryInfo?.courier?.phone || '';
        const text = `🚚 Buyurtmangiz yetkazilmoqda\n\nKuryer: ${courierName || '—'}\nTelefon: ${courierPhone || '—'}\nETA: ${etaText}`;
        const { bot } = require('../../index');
        await bot.telegram.sendMessage(order.user.telegramId, text);
      }
    } catch {}
    const changed = existingOrder.deliveryInfo?.courier && String(existingOrder.deliveryInfo.courier) !== String(courierId);
    res.json({ success: true, message: changed ? 'Kuryer o\'zgartirildi!' : 'Haydovchi tayinlandi!', data: { order } });
  } catch (error) {
    console.error('Assign courier error:', error);
    res.status(500).json({ success: false, message: 'Haydovchi tayinlashda xatolik!' });
  }
}

// ========================================
// 🚚 COURIER FLOW FUNCTIONS
// ========================================

// Kuryer buyurtmani qabul qiladi
async function courierAcceptOrder(req, res) {
  try {
    const { orderId } = req.params;
    const { latitude, longitude } = req.body;
    
    const order = await Order.findById(orderId);
    if (!order) {
      return res.status(404).json({ success: false, message: 'Buyurtma topilmadi!' });
    }
    
    if (order.status !== 'assigned') {
      return res.status(400).json({ success: false, message: 'Buyurtma hali kuryerga tayinlanmagan!' });
    }
    
    // Kuryer oqimini yangilash
    order.courierFlow = order.courierFlow || {};
    order.courierFlow.acceptedAt = new Date();
    order.courierFlow.currentLocation = {
      latitude: parseFloat(latitude),
      longitude: parseFloat(longitude),
      timestamp: new Date()
    };
    
    await order.save();
    
    // Real-time yangilash
    try {
      SocketManager.emitOrderStatusUpdateToBranch(order.branch, {
        orderId: order._id,
        status: 'assigned',
        courierAccepted: true,
        courierLocation: order.courierFlow.currentLocation,
        updatedAt: new Date()
      });
    } catch (e) {
      console.error('Socket emit error:', e);
    }
    
    res.json({ success: true, message: 'Buyurtma qabul qilindi!' });
  } catch (error) {
    console.error('Courier accept order error:', error);
    res.status(500).json({ success: false, message: 'Buyurtmani qabul qilishda xatolik!' });
  }
}

// Kuryer buyurtmani olib ketdi
async function courierPickedUpOrder(req, res) {
  try {
    const { orderId } = req.params;
    const { latitude, longitude } = req.body;
    
    const order = await Order.findById(orderId);
    if (!order) {
      return res.status(404).json({ success: false, message: 'Buyurtma topilmadi!' });
    }
    
    if (order.status !== 'ready') {
      return res.status(400).json({ success: false, message: 'Buyurtma hali tayyor emas!' });
    }
    
    // 1️⃣ RESTORANGA YAQINLIKNI TEKSHIRISH
    const branch = await Branch.findById(order.branch);
    if (branch?.address?.coordinates?.latitude && branch?.address?.coordinates?.longitude) {
      const distanceToRestaurant = calculateDistance(
        parseFloat(latitude),
        parseFloat(longitude),
        branch.address.coordinates.latitude,
        branch.address.coordinates.longitude
      );
      
      // 200 metrdan uzoq bo'lsa ogohlantirish
      if (distanceToRestaurant > 0.2) { // 0.2 km = 200 metr
        return res.json({
          success: false,
          warning: true,
          message: `❌ Restoranga juda uzoqdasiz! Sizdan ${(distanceToRestaurant * 1000).toFixed(0)} metr uzoqda. Restoranga yaqinroq boring va qaytadan urinib ko'ring.`,
          distance: distanceToRestaurant,
          requiredDistance: 0.2
        });
      }
    }
    
    // Kuryer oqimini yangilash
    order.courierFlow = order.courierFlow || {};
    order.courierFlow.pickedUpAt = new Date();
    order.courierFlow.pickedUpLocation = {
      latitude: parseFloat(latitude),
      longitude: parseFloat(longitude)
    };
    order.courierFlow.currentLocation = {
      latitude: parseFloat(latitude),
      longitude: parseFloat(longitude),
      timestamp: new Date()
    };
    
    // Status yangilash
    order.status = 'picked_up';
    order.statusHistory.push({
      status: 'picked_up',
      timestamp: new Date(),
      note: 'Kuryer buyurtmani olib ketdi',
      updatedBy: 'courier'
    });
    
    await order.save();
    
    // Real-time yangilash
    try {
      SocketManager.emitOrderStatusUpdateToBranch(order.branch, {
        orderId: order._id,
        status: 'picked_up',
        courierPickedUp: true,
        courierLocation: order.courierFlow.pickedUpLocation,
        updatedAt: new Date()
      });
    } catch (e) {
      console.error('Socket emit error:', e);
    }
    
    res.json({ success: true, message: '✅ Buyurtma muvaffaqiyatli olib ketildi!' });
  } catch (error) {
    console.error('Courier picked up order error:', error);
    res.status(500).json({ success: false, message: 'Buyurtmani olib ketishda xatolik!' });
  }
}

// Kuryer yo'lda
async function courierOnWay(req, res) {
  try {
    const { orderId } = req.params;
    const { latitude, longitude } = req.body;
    
    const order = await Order.findById(orderId);
    if (!order) {
      return res.status(404).json({ success: false, message: 'Buyurtma topilmadi!' });
    }
    
    if (!['picked_up', 'assigned'].includes(order.status)) {
      return res.status(400).json({ success: false, message: 'Buyurtma holati noto\'g\'ri!' });
    }
    
    // Kuryer oqimini yangilash
    order.courierFlow = order.courierFlow || {};
    order.courierFlow.onWayAt = new Date();
    order.courierFlow.currentLocation = {
      latitude: parseFloat(latitude),
      longitude: parseFloat(longitude),
      timestamp: new Date()
    };
    
    // Status yangilash
    if (order.status === 'assigned') {
      order.status = 'on_delivery';
      order.statusHistory.push({
        status: 'on_delivery',
        timestamp: new Date(),
        note: 'Kuryer yo\'lda',
        updatedBy: 'courier'
      });
    }
    
    await order.save();
    
    // Real-time yangilash
    try {
      SocketManager.emitOrderStatusUpdateToBranch(order.branch, {
        orderId: order._id,
        status: order.status,
        courierOnWay: true,
        courierLocation: order.courierFlow.currentLocation,
        updatedAt: new Date()
      });
    } catch (e) {
      console.error('Socket emit error:', e);
    }
    
    res.json({ success: true, message: 'Kuryer yo\'lda!' });
  } catch (error) {
    console.error('Courier on way error:', error);
    res.status(500).json({ success: false, message: 'Kuryer holatini yangilashda xatolik!' });
  }
}

// Kuryer yetkazdi
async function courierDeliveredOrder(req, res) {
  try {
    const { orderId } = req.params;
    const { latitude, longitude } = req.body;
    
    const order = await Order.findById(orderId);
    if (!order) {
      return res.status(404).json({ success: false, message: 'Buyurtma topilmadi!' });
    }
    
    if (!['picked_up', 'on_delivery'].includes(order.status)) {
      return res.status(400).json({ success: false, message: 'Buyurtma holati noto\'g\'ri!' });
    }
    
    // 2️⃣ MIJOZGA YAQINLIKNI TEKSHIRISH
    if (order.deliveryInfo?.location?.latitude && order.deliveryInfo?.location?.longitude) {
      const distanceToCustomer = calculateDistance(
        parseFloat(latitude),
        parseFloat(longitude),
        order.deliveryInfo.location.latitude,
        order.deliveryInfo.location.longitude
      );
      
      // 100 metrdan uzoq bo'lsa ogohlantirish
      if (distanceToCustomer > 0.1) { // 0.1 km = 100 metr
        return res.json({
          success: false,
          warning: true,
          message: `❌ Mijozga juda uzoqdasiz! Sizdan ${(distanceToCustomer * 1000).toFixed(0)} metr uzoqda. Mijozga yaqinroq boring va qaytadan urinib ko'ring.`,
          distance: distanceToCustomer,
          requiredDistance: 0.1
        });
      }
    }
    
    // Kuryer oqimini yangilash
    order.courierFlow = order.courierFlow || {};
    order.courierFlow.deliveredAt = new Date();
    order.courierFlow.deliveredLocation = {
      latitude: parseFloat(latitude),
      longitude: parseFloat(longitude)
    };
    order.courierFlow.currentLocation = {
      latitude: parseFloat(latitude),
      longitude: parseFloat(longitude),
      timestamp: new Date()
    };
    
    // Status yangilash
    order.status = 'delivered';
    order.statusHistory.push({
      status: 'delivered',
      timestamp: new Date(),
      note: 'Kuryer yetkazdi',
      updatedBy: 'courier'
    });
    
    await order.save();
    
    // Real-time yangilash
    try {
      SocketManager.emitOrderStatusUpdateToBranch(order.branch, {
        orderId: order._id,
        status: 'delivered',
        courierDelivered: true,
        courierLocation: order.courierFlow.deliveredLocation,
        updatedAt: new Date()
      });
    } catch (e) {
      console.error('Socket emit error:', e);
    }
    
    res.json({ success: true, message: '✅ Buyurtma muvaffaqiyatli yetkazildi!' });
  } catch (error) {
    console.error('Courier delivered order error:', error);
    res.status(500).json({ success: false, message: 'Buyurtmani yetkazishda xatolik!' });
  }
}

// Kuryer bekor qildi
async function courierCancelledOrder(req, res) {
  try {
    const { orderId } = req.params;
    const { latitude, longitude, reason } = req.body;
    
    const order = await Order.findById(orderId);
    if (!order) {
      return res.status(404).json({ success: false, message: 'Buyurtma topilmadi!' });
    }
    
    if (!['assigned', 'picked_up', 'on_delivery'].includes(order.status)) {
      return res.status(400).json({ success: false, message: 'Buyurtma holati noto\'g\'ri!' });
    }
    
    // Kuryer oqimini yangilash
    order.courierFlow = order.courierFlow || {};
    order.courierFlow.cancelledAt = new Date();
    order.courierFlow.cancelledLocation = {
      latitude: parseFloat(latitude),
      longitude: parseFloat(longitude)
    };
    order.courierFlow.currentLocation = {
      latitude: parseFloat(latitude),
      longitude: parseFloat(longitude),
      timestamp: new Date()
    };
    
    // Status yangilash
    order.status = 'cancelled';
    order.statusHistory.push({
      status: 'cancelled',
      timestamp: new Date(),
      note: `Kuryer bekor qildi: ${reason || 'Sabab ko\'rsatilmagan'}`,
      updatedBy: 'courier'
    });
    
    // Kuryerni olib tashlash
    order.deliveryInfo.courier = null;
    
    await order.save();
    
    // Real-time yangilash
    try {
      SocketManager.emitOrderStatusUpdateToBranch(order.branch, {
        orderId: order._id,
        status: 'cancelled',
        courierCancelled: true,
        courierLocation: order.courierFlow.cancelledLocation,
        updatedAt: new Date()
      });
    } catch (e) {
      console.error('Socket emit error:', e);
    }
    
    res.json({ success: true, message: 'Buyurtma bekor qilindi!' });
  } catch (error) {
    console.error('Courier cancelled order error:', error);
    res.status(500).json({ success: false, message: 'Buyurtmani bekor qilishda xatolik!' });
  }
}

// Kuryer lokatsiyasini yangilash
async function updateCourierLocation(req, res) {
  try {
    const { orderId } = req.params;
    const { latitude, longitude } = req.body;
    
    const order = await Order.findById(orderId);
    if (!order) {
      return res.status(404).json({ success: false, message: 'Buyurtma topilmadi!' });
    }
    
    if (!order.deliveryInfo?.courier) {
      return res.status(400).json({ success: false, message: 'Buyurtma kuryerga tayinlanmagan!' });
    }
    
    // Lokatsiyani yangilash
    order.courierFlow = order.courierFlow || {};
    order.courierFlow.currentLocation = {
      latitude: parseFloat(latitude),
      longitude: parseFloat(longitude),
      timestamp: new Date()
    };
    
    await order.save();
    
    // Real-time yangilash
    try {
      SocketManager.emitOrderStatusUpdateToBranch(order.branch, {
        orderId: order._id,
        courierLocation: order.courierFlow.currentLocation,
        updatedAt: new Date()
      });
    } catch (e) {
      console.error('Socket emit error:', e);
    }
    
    res.json({ success: true, message: 'Lokatsiya yangilandi!' });
  } catch (error) {
    console.error('Update courier location error:', error);
    res.status(500).json({ success: false, message: 'Lokatsiyani yangilashda xatolik!' });
  }
}

// Masofa tekshirish va ogohlantirish
async function checkCourierDistance(req, res) {
  try {
    const { orderId } = req.params;
    const { latitude, longitude } = req.body;
    
    const order = await Order.findById(orderId);
    if (!order) {
      return res.status(404).json({ success: false, message: 'Buyurtma topilmadi!' });
    }
    
    if (!order.deliveryInfo?.courier) {
      return res.status(400).json({ success: false, message: 'Buyurtma kuryerga tayinlanmagan!' });
    }
    
    // Masofani hisoblash
    const distance = calculateDistance(
      parseFloat(latitude),
      parseFloat(longitude),
      order.deliveryInfo.location.latitude,
      order.deliveryInfo.location.longitude
    );
    
    // 100 metrdan uzoq bo'lsa ogohlantirish
    if (distance > 0.1) { // 0.1 km = 100 metr
      return res.json({
        success: true,
        warning: true,
        message: `Kuryer sizdan ${(distance * 1000).toFixed(0)} metr uzoqda! Yaqinroq boring.`,
        distance: distance
      });
    }
    
    res.json({
      success: true,
      warning: false,
      message: 'Kuryer yaqin atrofda!',
      distance: distance
    });
  } catch (error) {
    console.error('Check courier distance error:', error);
    res.status(500).json({ success: false, message: 'Masofani tekshirishda xatolik!' });
  }
}

// Masofa hisoblash funksiyasi
function calculateDistance(lat1, lon1, lat2, lon2) {
  const R = 6371; // Yer radiusi (km)
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
    Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

module.exports = { 
  listOrders, 
  getOrder, 
  getOrderById,
  getStats, 
  updateStatus, 
  assignCourier,
  courierAcceptOrder,
  courierPickedUpOrder,
  courierOnWay,
  courierDeliveredOrder,
  courierCancelledOrder,
  updateCourierLocation,
  checkCourierDistance
};


