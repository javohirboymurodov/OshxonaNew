// User callback handlers - Refactored and optimized
const CatalogHandlers = require('../handlers/user/catalog/index');
const ProductHandlers = require('../handlers/user/catalog/productHandlers');

const {
  addToCart,
  updateQuantity,
  removeFromCart,
  showCart,
  clearCart
} = require('../handlers/user/cart');

// const UserOrderHandlers = require('../handlers/user/order/index'); // Temporarily commented due to legacy syntax issue
const { showMyOrders, myOrdersCallbackHandler } = require('../handlers/user/myOrders');
const loyaltyHandlers = require('../handlers/user/loyalty/loyaltyHandlers');
const trackingHandlers = require('../handlers/user/tracking/trackingHandlers');
const quickOrderHandlers = require('../handlers/user/ux/quickOrderHandlers');

// Import organized handler modules
const NavigationHandlers = require('../handlers/user/navigationHandlers');
const ContactAndAboutHandlers = require('../handlers/user/contactAndAboutHandlers');
const PromotionHandlers = require('../handlers/user/promotionHandlers');
const RatingHandlers = require('../handlers/user/ratingHandlers');
const CourierCallbacks = require('../handlers/user/courierCallbacks');

const { User } = require('../../models');
const UXImprovements = require('../../improvements/ux-improvements');

/**
 * User callback handlers ni bot instance ga ulash
 * @param {Telegraf} bot - Telegraf bot instance
 */
function registerUserCallbacks(bot) {
  // Debug logger for all callback queries
  bot.use(async (ctx, next) => {
    if (ctx.updateType === 'callback_query') {
      try {
        const data = String(ctx.callbackQuery?.data || '');
        console.log('üéØ callback_query received:', data, '| from:', ctx.from?.id);
      } catch (e) {
        console.error('üéØ callback_query log error:', e);
      }
    }
    return next();
  });
  // Apply phone guard middleware
  bot.use(NavigationHandlers.phoneGuardMiddleware);

  // Register organized handler modules
  NavigationHandlers.registerCallbacks(bot);
  ContactAndAboutHandlers.registerCallbacks(bot);
  PromotionHandlers.registerCallbacks(bot);
  RatingHandlers.registerCallbacks(bot);
  CourierCallbacks.registerCallbacks(bot);

  // ========================================
  // üìÇ CATALOG & CATEGORIES
  // ========================================

  bot.action('show_categories', async (ctx) => { await CatalogHandlers.showCategories(ctx); });
  bot.action('show_catalog', async (ctx) => { await CatalogHandlers.showCategories(ctx); });

  // Cart
  bot.action('show_cart', async (ctx) => {
    try {
      const { showCart } = require('../handlers/user/cart');
      await showCart(ctx);
    } catch (e) {
      console.error('show_cart error', e);
      if (ctx.answerCbQuery) await ctx.answerCbQuery('‚ùå Savatni ochib bo\'lmadi');
    }
  });

  // Branches
  bot.action('show_branches', async (ctx) => { await CatalogHandlers.showBranches(ctx, 1); });
  
  // Nearest branch - request location
  bot.action('nearest_branch', async (ctx) => {
    try {
      await ctx.editMessageText(
        'üìç **Eng yaqin filialni topish**\n\nJoylashuvingizni ulashing:',
        {
          parse_mode: 'Markdown',
          reply_markup: {
            inline_keyboard: [
              [{ text: 'üìç Joylashuvni ulashish', callback_data: 'request_location' }],
              [{ text: 'üîô Orqaga', callback_data: 'show_branches' }]
            ]
          }
        }
      );
    } catch (error) {
      console.error('‚ùå nearest_branch error:', error);
      if (ctx.answerCbQuery) await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });
  
  // Branch selection and details (nearest/branch_<id>)
  bot.action(/^branch_.+$/, async (ctx) => { 
    try {
      await CatalogHandlers.handleBranchSelection(ctx);
      
      // Show promotions after branch selection
      const branchId = ctx.callbackQuery?.data?.replace('branch_', '');
      if (branchId && branchId !== 'nearest') {
        const promoData = await PromotionHandlers.showBranchPromotions(branchId);
        if (promoData) {
          await ctx.reply(promoData.message, {
              parse_mode: 'Markdown',
            reply_markup: promoData.keyboard
          });
        }
      }
    } catch (e) {
      console.error('branch selection error:', e);
    }
  });

  // Request location for nearest branch
  bot.action('request_location', async (ctx) => {
    try {
      // Set waiting state for nearest branch
      ctx.session = ctx.session || {};
      ctx.session.waitingFor = 'branch_location';
      
      await ctx.editMessageText('üìç Joylashuvingizni ulashing:', {
        reply_markup: {
          inline_keyboard: [[{ text: 'üîô Orqaga', callback_data: 'show_branches' }]]
        }
      });
      await ctx.reply('üìç Pastdagi tugma orqali joylashuvingizni yuboring:', {
        reply_markup: {
          keyboard: [[{ text: 'üìç Joylashuvni yuborish', request_location: true }]],
          resize_keyboard: true,
          one_time_keyboard: true
        }
      });
    } catch (error) {
      console.error('‚ùå request_location error:', error);
      if (ctx.answerCbQuery) await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Branch location sharing
  bot.action(/^share_branch_location_(.+)$/, async (ctx) => {
    try { await CatalogHandlers.shareBranchLocation(ctx, ctx.match[1]); } catch (e) { console.error('share_branch_location error', e); }
  });

  // Branch phone display
  bot.action(/^branch_phone_([0-9a-fA-F]{24})$/, async (ctx) => {
    try {
      const { Branch } = require('../../models');
      const id = ctx.match && ctx.match[1] ? ctx.match[1] : (ctx.callbackQuery?.data || '').replace('branch_phone_', '');
      const b = await Branch.findById(id).select('phone');
      if (!b) return ctx.answerCbQuery('‚ùå Filial topilmadi');
      await ctx.reply(`üìû ${b.phone || 'Telefon raqami topilmadi'}`);
      if (ctx.answerCbQuery) await ctx.answerCbQuery('üìû Telefon');
    } catch (e) { console.error('branch_phone error', e); }
  });

  // Location request for nearest branch
  bot.action('request_location', async (ctx) => {
    try {
      ctx.session.waitingFor = 'branch_location';
      await ctx.editMessageText('üìç Joylashuvingizni ulashing:', {
        reply_markup: {
          inline_keyboard: [[{ text: 'üîô Orqaga', callback_data: 'show_branches' }]]
        }
      });
      try {
        await ctx.reply('üìç Pastdagi tugma orqali joylashuvingizni yuboring:', {
          reply_markup: {
            keyboard: [[{ text: 'üìç Joylashuvni yuborish', request_location: true }]],
            resize_keyboard: true,
            one_time_keyboard: true
          }
        });
      } catch {}
    } catch (e) {
      console.error('request_location error', e);
    }
  });

  // Category handling
  bot.action(/^category_(.+)$/, async (ctx) => {
    console.log('üî• CATEGORY CALLBACK TRIGGERED:', ctx.match);
    const categoryId = ctx.match[1];
    console.log('üìã Category ID extracted:', categoryId);
    try {
      await ProductHandlers.showCategoryProducts(ctx, categoryId);
      console.log('‚úÖ Category products shown successfully');
    } catch (error) {
      console.error('‚ùå Category products error:', error);
      await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Profile
  bot.action('my_profile', async (ctx) => {
    try {
      const { showProfile } = require('../handlers/user/profile');
      await showProfile(ctx);
    } catch (e) {
      console.error('my_profile error:', e);
    }
  });

  // ========================================
  // üì¶ PRODUCT HANDLING
  // ========================================

  // Product details callback (for product_details_* pattern) - MUST BE FIRST!
  bot.action(/^product_details_(.+)$/, async (ctx) => {
    console.log('üî• PRODUCT DETAILS CALLBACK TRIGGERED:', {
      callbackData: ctx.callbackQuery?.data,
      match: ctx.match,
      matchLength: ctx.match?.length,
      extractedId: ctx.match?.[1]
    });
    let productId = ctx.match?.[1];
    if (!productId && ctx.callbackQuery?.data) {
      const manualMatch = ctx.callbackQuery.data.match(/^product_details_(.+)$/);
      productId = manualMatch?.[1];
      console.log('üì¶ Manual ProductId extraction:', productId);
    }
    console.log('üì¶ Final Product Details ID:', productId);
    if (!productId) {
      console.error('‚ùå ProductId extraction failed from callback:', ctx.callbackQuery?.data);
      return await ctx.answerCbQuery('‚ùå Mahsulot ID noto\'g\'ri!');
    }
    try {
      await ProductHandlers.showProductDetails(ctx, productId);
      console.log('‚úÖ Product details shown successfully');
    } catch (error) {
      console.error('‚ùå Product details error:', error);
      await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Generic product callback (for simple product_* pattern)
  bot.action(/^product_(.+)$/, async (ctx) => {
    console.log('üî• GENERIC PRODUCT CALLBACK TRIGGERED:', ctx.match);
    const productId = ctx.match[1];
    console.log('üì¶ Generic Product ID extracted:', productId);
    try {
      await ProductHandlers.showProductDetails(ctx, productId);
      console.log('‚úÖ Generic product details shown successfully');
    } catch (error) {
      console.error('‚ùå Generic product details error:', error);
      await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Category products pagination: category_products_<categoryId>_<page>
  bot.action(/^category_products_([0-9a-fA-F]{24})_(\d+)$/, async (ctx) => {
    try {
      const [, categoryId, pageStr] = ctx.callbackQuery.data.match(/^category_products_([0-9a-fA-F]{24})_(\d+)$/) || [];
      const page = parseInt(pageStr, 10) || 1;
      await ProductHandlers.showCategoryProducts(ctx, categoryId, page);
    } catch (e) {
      console.error('category_products pagination error', e);
    }
  });

  // ========================================
  // üõí CART ACTIONS
  // ========================================

  // Support both add_to_cart_<productId> and add_cart_<productId>_<qty>
  bot.action(/^add_to_cart_.+$/, async (ctx) => { await addToCart(ctx); });
  bot.action(/^add_cart_.+$/, async (ctx) => { await addToCart(ctx); });

  // Support change_qty_ and cart_qty_ patterns
  bot.action(/^(change_qty|cart_qty)_.+_(-?\d+)$/, async (ctx) => { await updateQuantity(ctx); });

  bot.action(/^remove_from_cart_(.+)$/, async (ctx) => {
    await removeFromCart(ctx);
  });



  bot.action('clear_cart', async (ctx) => {
    await clearCart(ctx);
  });

  // ========================================
  // üìã ORDER FLOW (lightweight fallback)
  // ========================================

  // Fallback: start_order -> open categories to let user choose items
  bot.action('start_order', async (ctx) => {
    try {
      await CatalogHandlers.showCategories(ctx);
    } catch (e) {
      console.error('start_order fallback error:', e);
      await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Fallback: checkout -> start order process
  bot.action('checkout', async (ctx) => {
    try {
      const UserOrderHandlers = require('../handlers/user/order/index');
      await UserOrderHandlers.startOrder(ctx);
    } catch (e) {
      console.error('checkout fallback error:', e);
      await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // ========================================
  // üìù ORDER TYPE HANDLERS
  // ========================================

  // Order type selection handlers
  bot.action('order_type_delivery', async (ctx) => {
    try {
      const UserOrderHandlers = require('../handlers/user/order/index');
      await UserOrderHandlers.handleOrderType(ctx);
    } catch (e) {
      console.error('order_type_delivery error:', e);
      await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  bot.action('order_type_pickup', async (ctx) => {
    try {
      const UserOrderHandlers = require('../handlers/user/order/index');
      await UserOrderHandlers.handleOrderType(ctx);
    } catch (e) {
      console.error('order_type_pickup error:', e);
      await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  bot.action('order_type_dine_in', async (ctx) => {
    try {
      const UserOrderHandlers = require('../handlers/user/order/index');
      await UserOrderHandlers.handleOrderType(ctx);
    } catch (e) {
      console.error('order_type_dine_in error:', e);
      await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Branch selection handlers
  bot.action(/^choose_branch_(pickup|dine)_[0-9a-fA-F]{24}$/, async (ctx) => {
    try {
      const OrderFlow = require('../handlers/user/order/orderFlow');
      await OrderFlow.handleChooseBranch(ctx);
    } catch (e) {
      console.error('choose_branch error:', e);
      await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Arrival time handlers
  bot.action(/^arrival_time_.+$/, async (ctx) => {
    try {
      const UserOrderHandlers = require('../handlers/user/order/index');
      await UserOrderHandlers.handleArrivalTime(ctx);
    } catch (e) {
      console.error('arrival_time error:', e);
      await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Order step back handler
  bot.action('order_step_back', async (ctx) => {
    try {
      const UserOrderHandlers = require('../handlers/user/order/index');
      await UserOrderHandlers.startOrder(ctx);
    } catch (e) {
      console.error('order_step_back error:', e);
      await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // ========================================
  // üí≥ PAYMENT HANDLERS
  // ========================================

  // Payment method handlers
  bot.action(/^payment_(cash|card|click|payme)$/, async (ctx) => {
    try {
      const paymentMethod = ctx.callbackQuery.data.replace('payment_', '');
      const PaymentFlow = require('../handlers/user/order/paymentFlow');
      await PaymentFlow.handlePaymentMethod(ctx, paymentMethod);
    } catch (e) {
      console.error('payment method error:', e);
      await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Order confirmation handler
  bot.action('confirm_order', async (ctx) => {
    try {
      const UserOrderHandlers = require('../handlers/user/order/index');
      await UserOrderHandlers.confirmOrder(ctx);
    } catch (e) {
      console.error('confirm_order error:', e);
      await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Order edit handler (go back to cart)
  bot.action('edit_order', async (ctx) => {
    try {
      const { showCart } = require('../handlers/user/cart');
      await showCart(ctx);
    } catch (e) {
      console.error('edit_order error:', e);
      await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Dine-in arrival handler
  bot.action('dinein_arrived_preview', async (ctx) => {
    try {
      await ctx.editMessageText(
        'üèÅ **Restoranga keldingizmi?**\n\nStol raqamingizni kiriting yoki quyidagi tugmani bosing:',
        {
          parse_mode: 'Markdown',
          reply_markup: {
            inline_keyboard: [
              [{ text: 'üìù Stol raqamini kiritish', callback_data: 'enter_table_number' }],
              [{ text: 'üîô Orqaga', callback_data: 'back_to_main' }]
            ]
          }
        }
      );
      ctx.session.waitingFor = 'table_number';
    } catch (e) {
      console.error('dinein_arrived_preview error:', e);
      await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Enter table number handler
  bot.action('enter_table_number', async (ctx) => {
    try {
      await ctx.editMessageText(
        'üìù **Stol raqamini kiriting:**\n\nMasalan: 12, A5, yoki 3B',
        {
          parse_mode: 'Markdown',
          reply_markup: {
            inline_keyboard: [
              [{ text: 'üîô Orqaga', callback_data: 'dinein_arrived_preview' }]
            ]
          }
        }
      );
      ctx.session.waitingFor = 'table_number';
      await ctx.answerCbQuery('Stol raqamini yozing');
    } catch (e) {
      console.error('enter_table_number error:', e);
      await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Skip address notes handler
  bot.action('skip_address_notes', async (ctx) => {
    try {
      ctx.session.waitingFor = null;
      await ctx.editMessageText('‚úÖ **Manzil tasdiqlandi!**\n\nTo\'lov usulini tanlang:', {
        parse_mode: 'Markdown'
      });
      const PaymentFlow = require('../handlers/user/order/paymentFlow');
      await PaymentFlow.askForPaymentMethod(ctx);
    } catch (e) {
      console.error('skip_address_notes error:', e);
      await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // ========================================
  // üìã MY ORDERS
  // ========================================

  bot.action('my_orders', async (ctx) => {
    try {
      await showMyOrders(ctx);
    } catch (error) {
      console.error('‚ùå my_orders error:', error);
      if (ctx.answerCbQuery) await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Pagination and details for "My Orders"
  bot.action(/^orders_page_\d+$/, async (ctx) => {
    try {
      await myOrdersCallbackHandler(ctx);
    } catch (error) {
      console.error('‚ùå my_orders pagination error:', error);
    }
  });

  bot.action(/^order_detail_.+$/, async (ctx) => {
    try {
      await myOrdersCallbackHandler(ctx);
    } catch (error) {
      console.error('‚ùå my_orders detail error:', error);
    }
  });

  bot.action('back_to_my_orders', async (ctx) => {
    try {
      await myOrdersCallbackHandler(ctx);
    } catch (error) {
      console.error('‚ùå back_to_my_orders error:', error);
    }
  });

  // ========================================
  // üíé LOYALTY PROGRAM
  // ========================================

  // Loyalty level
  bot.action('my_loyalty_level', async (ctx) => {
    try {
      await loyaltyHandlers.showMyLevel(ctx);
    } catch (error) {
      console.error('‚ùå my_loyalty_level error:', error);
      if (ctx.answerCbQuery) await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Bonuses
  bot.action('my_bonuses', async (ctx) => {
    try {
      await loyaltyHandlers.showMyBonuses(ctx);
    } catch (error) {
      console.error('‚ùå my_bonuses error:', error);
      if (ctx.answerCbQuery) await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Referral program
  bot.action('referral_program', async (ctx) => {
    try {
      await loyaltyHandlers.showReferralProgram(ctx);
    } catch (error) {
      console.error('‚ùå referral_program error:', error);
      if (ctx.answerCbQuery) await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Use points
  bot.action('use_points', async (ctx) => {
    try {
      await loyaltyHandlers.usePoints(ctx);
    } catch (error) {
      console.error('‚ùå use_points error:', error);
      if (ctx.answerCbQuery) await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Use points - amounts
  bot.action(/^use_points_(\d+)$/, async (ctx) => {
    try {
      const amount = parseInt(ctx.match[1]);
      ctx.session.pointsToUse = amount;
      
      const user = await User.findOne({ telegramId: ctx.from.id });
      if (!user || user.loyaltyPoints < amount) {
        await ctx.answerCbQuery('‚ùå Yetarli ball yo\'q!', { show_alert: true });
        return;
      }

      await ctx.answerCbQuery(`‚úÖ ${amount.toLocaleString()} ball tanlandi`);
      await ctx.editMessageText(
        `‚úÖ <b>${amount.toLocaleString()} ball tanlandi</b>\n\nüí° Keyingi buyurtmangizda avtomatik qo'llaniladi.\n\nüõí Buyurtma berishni boshlaysizmi?`,
        {
          parse_mode: 'HTML',
          reply_markup: {
            inline_keyboard: [
              [{ text: 'üõí Buyurtma berish', callback_data: 'start_order' }],
              [{ text: 'üîô Orqaga', callback_data: 'my_bonuses' }]
            ]
          }
        }
      );
    } catch (error) {
      console.error('‚ùå use_points_amount error:', error);
      if (ctx.answerCbQuery) await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // My stats
  bot.action('my_stats', async (ctx) => {
    try {
      await loyaltyHandlers.showMyStats(ctx);
    } catch (error) {
      console.error('‚ùå my_stats error:', error);
      if (ctx.answerCbQuery) await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // ========================================
  // üìç ORDER TRACKING
  // ========================================

  // Track order (Smart Interface)
  bot.action(/^track_(.+)$/, async (ctx) => {
    try {
      await trackingHandlers.trackOrderSmart(ctx);
    } catch (error) {
      console.error('‚ùå track_order error:', error);
      if (ctx.answerCbQuery) await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // ========================================
  // üöÄ SMART ORDER INTERFACE (Professional)
  // ========================================
  
  // Smart order refresh with rate limiting
  const refreshRateLimiter = new Map();
  bot.action(/^smart_refresh_(.+)$/, async (ctx) => {
    try {
      const orderId = ctx.match[1];
      const userId = ctx.from.id;
      const rateLimitKey = `refresh_${userId}_${orderId}`;
      
      // Rate limiting: 1 refresh per 3 seconds
      const lastRefresh = refreshRateLimiter.get(rateLimitKey);
      const now = Date.now();
      if (lastRefresh && (now - lastRefresh) < 3000) {
        await ctx.answerCbQuery('‚è≥ Iltimos, biroz kuting...');
        return;
      }
      
      refreshRateLimiter.set(rateLimitKey, now);
      
      const SmartOrderInterface = require('../../services/smartOrderInterface');
      await SmartOrderInterface.refreshOrder(ctx, orderId);
      
      // Clean up old entries (older than 10 seconds)
      setTimeout(() => {
        for (const [key, timestamp] of refreshRateLimiter.entries()) {
          if (now - timestamp > 10000) {
            refreshRateLimiter.delete(key);
          }
        }
      }, 1000);
      
    } catch (error) {
      console.error('‚ùå smart_refresh error:', error);
      if (ctx.answerCbQuery) await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Smart order display from tracking
  bot.action(/^smart_order_(.+)$/, async (ctx) => {
    try {
      const orderId = ctx.match[1];
      const SmartOrderInterface = require('../../services/smartOrderInterface');
      await SmartOrderInterface.showOrder(ctx, orderId, { source: 'tracking' });
    } catch (error) {
      console.error('‚ùå smart_order error:', error);
      if (ctx.answerCbQuery) await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // ========================================
  // ‚≠ê RATING SYSTEM
  // ========================================
  
  // Order rating (show stars)
  bot.action(/^rate_order_(.+)$/, async (ctx) => {
    try {
      const orderId = ctx.match[1];
      await RatingHandlers.showRatingOptions(ctx, orderId);
    } catch (error) {
      console.error('‚ùå rate_order error:', error);
      if (ctx.answerCbQuery) await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Star rating selection
  bot.action(/^rate_(.+)_(\d+)$/, async (ctx) => {
    try {
      await RatingHandlers.handleRating(ctx);
    } catch (error) {
      console.error('‚ùå rate star error:', error);
      if (ctx.answerCbQuery) await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Feedback after rating
  bot.action(/^feedback_(.+)$/, async (ctx) => {
    try {
      const orderId = ctx.match[1];
      await RatingHandlers.requestFeedback(ctx, orderId);
    } catch (error) {
      console.error('‚ùå feedback error:', error);
      if (ctx.answerCbQuery) await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Courier location
  bot.action(/^courier_location_(.+)$/, async (ctx) => {
    try {
      await trackingHandlers.showCourierLocation(ctx);
    } catch (error) {
      console.error('‚ùå courier_location error:', error);
      if (ctx.answerCbQuery) await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Reorder
  bot.action(/^reorder_(.+)$/, async (ctx) => {
    try {
      await trackingHandlers.reorderItem(ctx);
    } catch (error) {
      console.error('‚ùå reorder error:', error);
      if (ctx.answerCbQuery) await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Confirm reorder
  bot.action(/^confirm_reorder_(.+)$/, async (ctx) => {
    try {
      await trackingHandlers.confirmReorder(ctx);
    } catch (error) {
      console.error('‚ùå confirm_reorder error:', error);
      if (ctx.answerCbQuery) await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // ========================================
  // ‚ö° QUICK ORDER & MOBILE UX
  // ========================================

  // Quick order menu
  bot.action('quick_order', async (ctx) => {
    try {
      await quickOrderHandlers.showQuickOrder(ctx);
    } catch (error) {
      console.error('‚ùå quick_order error:', error);
      if (ctx.answerCbQuery) await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Quick popular products
  bot.action('quick_popular', async (ctx) => {
    try {
      await quickOrderHandlers.showPopularProducts(ctx);
    } catch (error) {
      console.error('‚ùå quick_popular error:', error);
      if (ctx.answerCbQuery) await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Quick fast products
  bot.action('quick_fast', async (ctx) => {
    try {
      await quickOrderHandlers.showFastProducts(ctx);
    } catch (error) {
      console.error('‚ùå quick_fast error:', error);
      if (ctx.answerCbQuery) await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Quick add product
  bot.action(/^quick_add_(.+)$/, async (ctx) => {
    try {
      await quickOrderHandlers.quickAddProduct(ctx);
    } catch (error) {
      console.error('‚ùå quick_add error:', error);
      if (ctx.answerCbQuery) await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Add to favorites
  bot.action(/^add_favorite_(.+)$/, async (ctx) => {
    try {
      await quickOrderHandlers.addToFavorites(ctx);
    } catch (error) {
      console.error('‚ùå add_favorite error:', error);
      if (ctx.answerCbQuery) await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Show favorites
  bot.action('show_favorites', async (ctx) => {
    try {
      await quickOrderHandlers.showFavorites(ctx);
    } catch (error) {
      console.error('‚ùå show_favorites error:', error);
      if (ctx.answerCbQuery) await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // Remove from favorites
  bot.action(/^remove_favorite_(.+)$/, async (ctx) => {
    try {
      await quickOrderHandlers.removeFromFavorites(ctx);
    } catch (error) {
      console.error('‚ùå remove_favorite error:', error);
      if (ctx.answerCbQuery) await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  // ========================================
  // üë®‚Äçüíº ADMIN QUICK ACTIONS (from Telegram notifications)
  // ========================================

  // Admin quick status updates
  bot.action(/^admin_quick_confirmed_(.+)$/, async (ctx) => {
    try {
      const orderId = ctx.match[1];
      const OrderStatusService = require('../../services/orderStatusService');
      await OrderStatusService.updateStatus(orderId, 'confirmed', {
        message: 'Admin tomonidan tasdiqlandi',
        updatedBy: ctx.from.id
      });
      await ctx.answerCbQuery('‚úÖ Buyurtma tasdiqlandi');
    } catch (error) {
      console.error('‚ùå admin_quick_confirmed error:', error);
      await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  bot.action(/^admin_quick_preparing_(.+)$/, async (ctx) => {
    try {
      const orderId = ctx.match[1];
      const OrderStatusService = require('../../services/orderStatusService');
      await OrderStatusService.updateStatus(orderId, 'preparing', {
        message: 'Buyurtma tayyorlanmoqda',
        updatedBy: ctx.from.id
      });
      await ctx.answerCbQuery('‚úÖ Tayyorlash boshlandi');
    } catch (error) {
      console.error('‚ùå admin_quick_preparing error:', error);
      await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  bot.action(/^admin_quick_ready_(.+)$/, async (ctx) => {
    try {
      const orderId = ctx.match[1];
      const OrderStatusService = require('../../services/orderStatusService');
      await OrderStatusService.updateStatus(orderId, 'ready', {
        message: 'Buyurtma tayyor',
        updatedBy: ctx.from.id
      });
      await ctx.answerCbQuery('‚úÖ Buyurtma tayyor');
    } catch (error) {
      console.error('‚ùå admin_quick_ready error:', error);
      await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  bot.action(/^admin_quick_delivered_(.+)$/, async (ctx) => {
    try {
      const orderId = ctx.match[1];
      const Order = require('../../models/Order');
      const order = await Order.findById(orderId);
      
      if (!order) {
        await ctx.answerCbQuery('‚ùå Buyurtma topilmadi');
        return;
      }

      const OrderStatusService = require('../../services/orderStatusService');
      
      // PICKUP uchun 'picked_up', DELIVERY uchun 'delivered'
      const finalStatus = order.orderType === 'pickup' ? 'picked_up' : 'delivered';
      
      await OrderStatusService.updateStatus(orderId, finalStatus, {
        message: order.orderType === 'pickup' ? 'Mijoz buyurtmani olib ketdi' : 'Buyurtma yetkazildi',
        updatedBy: ctx.from.id
      });
      
      await ctx.answerCbQuery(order.orderType === 'pickup' ? '‚úÖ Olib ketildi' : '‚úÖ Yetkazildi');
    } catch (error) {
      console.error('‚ùå admin_quick_delivered error:', error);
      await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  bot.action(/^admin_quick_picked_up_(.+)$/, async (ctx) => {
    try {
      const orderId = ctx.match[1];
      const OrderStatusService = require('../../services/orderStatusService');
      await OrderStatusService.updateStatus(orderId, 'picked_up', {
        message: 'Mijoz buyurtmani olib ketdi',
        updatedBy: ctx.from.id
      });
      await ctx.answerCbQuery('‚úÖ Olib ketildi');
    } catch (error) {
      console.error('‚ùå admin_quick_picked_up error:', error);
      await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  bot.action(/^admin_quick_cancelled_(.+)$/, async (ctx) => {
    try {
      const orderId = ctx.match[1];
      const OrderStatusService = require('../../services/orderStatusService');
      await OrderStatusService.updateStatus(orderId, 'cancelled', {
        message: 'Admin tomonidan bekor qilindi',
        updatedBy: ctx.from.id
      });
      await ctx.answerCbQuery('‚úÖ Buyurtma bekor qilindi');
    } catch (error) {
      console.error('‚ùå admin_quick_cancelled error:', error);
      await ctx.answerCbQuery('‚ùå Xatolik yuz berdi!');
    }
  });

  console.log('‚úÖ User callbacks registered (optimized)');
}

module.exports = { registerUserCallbacks };

